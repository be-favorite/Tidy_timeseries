---
title: "<center> **<font size = 5>tidyvert: tidy tools for time series **</font> </center>"
author: "방태모"
date: "2021-04-12"
output: 
  rmdformats::robobook
editor_options: 
  markdown: 
    wrap: 72
---
<style>
.math {
  font-size: small;
}
</style>

<br>

## **0 Before Start**
***
If you are familiar with English, go to [7 Reference](#anchor1). And this text is provided by [my Github repository](https://github.com/be-favorite/tidyverts)

<br>

## **1 Preparing**
***
tidyverts ecosystem을 이루는 대부분의 패키지들은 [Introduction](https://github.com/be-favorite/tidyverts)에서 말했듯이, {fpp3}으로 불러올 수 있습니다:
```{r}
library(fpp3)
```

```{r, message = FALSE}
library(fable.prophet)
library(tsibbletalk)
library(nycflights13) # for nycflights13 data
library(purrr) # for map()
library(shiny) # for {tsibbletalk}
ggplot2::theme_set(theme_minimal())
loaded_package <- c("fable.prophet", "tsibbletalk", "nycflights13", "purrr", "shiny")
.version <- map(loaded_package, packageVersion)
names(.version) <- loaded_package
.version
```

위 패키지들이 설치되어 있지 않은 분들은 튜토리얼의 본격적인 시작전에, `install.packages("패키지명")`을 통해 설치해주시기 바랍니다. 개발 버전을 설치하고 싶다면 다음과 같은 코드를 활용하면 됩니다:
```{r, eval = FALSE}
# install.packages("remotes")
remotes::install_github("tidyverts/tsibble")
```

<br>

<a href='https://tsibble.tidyverts.org/'><img src='logo_tsibble.png' align="right" height="138.5" /></a>

## **2 tsibble**
***

### 2.1 Get Started
{tsibble}은 일반적인 시계열 자료를 `tibble` 형태로 표현할 수 있게해줍니다. 우리는 `tsibble()`을 통해 [tidy한 자료](https://tidyr.tidyverse.org/articles/tidy-data.html)에 대해 수행해왔던 {tidyverse}를 이용한 wrangling을 수행할 수 있습니다. 즉, tidyverse ecosystem이 tibble 객체를 기반으로 동작하듯이, tidyverts ecosytem은 tsibble 객체를 기반으로 동작합니다. tsibble 객체가 갖는 기본적인 원칙은 다음과 같습니다:

* `index`: 과거부터 현재까지 순서화된 자료값의 관측 시간
* `key`: 시간에 따른 관측 단위를 정의하는 변수의 집합
* 각 관측치는 `index`와 `key`를 통해 유일하게(uniquely) 식별되어야만 함
* 각 관측치는 등간격으로 관측된 자료여야만 함

즉, 티블(데이터프레임)을 `tsibble`로 변환하기(coerce) 위해서는 `key`와 `index`를 명시해주어야 합니다. 예를 들어, 다음과 같은 {nycflights13} 패키지의 `weather` 자료를 이용해보겠습니다:
```{r}
weather_simple <- nycflights13::weather %>% 
    select(origin, time_hour, temp, humid, precip)
weather_simple
```

`origin`을 `key`로 `index`를 `time_hour`로 해주면 될 것 같습니다:
```{r}
weather_tsbl <- as_tsibble(weather_simple, key = origin, index = time_hour)
weather_tsbl
```

여기서는 자료 자체가 출발지(`origin`) 별로 기록된 다중(multiple) 시계열에 해당하므로, `key`를 `origin`으로 잡아줬지만, 만약 자료가 단일(univariate) 시계열에 해당한다면 해당 key는 설정을 하지 않으면 됩니다(see `package?tsibble` and `vignette("intro-tsibble")` for details). 그리고, 사실 `tsibble()`은 irregular time interval을 갖는 자료에 대해서도 적용이 가능합니다. as_tsibble은 `regular = TRUE` 옵션이 default로 설정되는데, 이를 `FALSE`로 바꿔주면 되며, 이러한 irregular time interval을 갖는 tsibble 객체의 경우는 `[!]` 표시를 통해 확인할 수 있습니다:
```{r}
nycflights13::flights %>%
    mutate(
      sched_dep_datetime = make_datetime(year, month, day, hour, minute, 
                                         tz = "America/New_York")) %>%
    as_tsibble(
        key = c(carrier, flight), 
        index = sched_dep_datetime, 
        regular = FALSE
        )
```


### 2.2 Turn impicit missing values into explicit missing values
간혹 시계열 자료에는 암묵적 결측치(implicit missing values)가 존재하는 경우가 있다. 암묵적 결측치가 존재하는 시계열 자료가 일정한 시간 간격으로 수집되었을 경우, 우리는 `fill_gaps()`를 이용해 암묵적 결측을 명시적으로(explicit) 바꿀 수 있다. 4년간 수집된 연도별 키위, 체리의 수확량(단위: kg)에 관한 자료를 직접 만들어서 `fill_gaps()`의 쓰임에 대해 알아보자. 본 자료에는 암묵적 결측이 존재한다:
```{r}
harvest <- tsibble(
    year = c(2010, 2011, 2013, 2011, 2012, 2014),
    fruit = rep(c("kiwi", "cherry"), each = 3),
    kilo = sample(1:10, size = 6),
    key = fruit, index = year
)
harvest
```

암묵적 결측이란, 예를 들어 위 자료처럼 체리 생산량이 2010년에는 기록되지 않았음에도 불구하고 행이 생략되어있는 것을 말한다. `NA`로 명시는 다음과 같이 손쉽게 가능하다:
```{r}
fill_gaps(harvest, .full = TRUE)
```

다음의 각각 시작점, 끝점에 대해서만 결측치를 명시한다:
```{r}
# at the same starting point across units
fill_gaps(harvest, .full = start())
# at the same end point across units
fill_gaps(harvest, .full = end())
```

`.full = FALSE`를 설정할 경우(`fill_gaps()`의 default 옵션에 해당), 각 key 내의 period에서 발생한 결측에 대해서만 명시가 이루어진다.
```{r}
fill_gaps(harvest, .full = FALSE)
```

특정값으로의 명시도 손쉽게 수행이 가능하다.
```{r}
harvest %>% 
    fill_gaps(kilo = 0L)
```

변수에 대해 함수를 적용하여 명시도 가능하다. `sum()`을 이용하여 합으로 명시해보았다:
```{r}
harvest %>%
    fill_gaps(kilo = sum(kilo))
```

`key`에 대해 `group_by`를 통해 각 그룹에 대해 함수를 적용할 수도 있다. 이번에는 `median()`을 통해 중위수로 명시해보았다:
```{r}
harvest %>%
    group_by_key() %>%
    fill_gaps(kilo = median(kilo))
```

원 자료 자체에 `NA`가 존재하는 경우, 적용하고자 하는 함수에 `na.rm = TRUE`을 설정해주면 된다:
```{r}
harvest[2, 3] <- NA
harvest %>%
    group_by_key() %>%
    fill_gaps(kilo = median(kilo, na.rm = TRUE))
```

마지막으로, `fill_gaps()`아 `tidyr::fill()`을 함께 이용하면 암묵적 결측치를 이전 시점의 결측치로 대치할 수 있다.
```{r}
harvest <- tsibble(
    year = c(2010, 2011, 2013, 2011, 2012, 2014),
    fruit = rep(c("kiwi", "cherry"), each = 3),
    kilo = sample(1:10, size = 6),
    key = fruit, index = year
)
harvest %>%
    group_by_key() %>%
    fill_gaps() %>%
    tidyr::fill(kilo, .direction = "down")
```

반대로, 한 시점 미래의 값으로 대치도 가능하다.
```{r}
harvest %>%
    group_by_key() %>%
    fill_gaps() %>%
    tidyr::fill(kilo, .direction = "up")
```

### 2.3 Aggregate over calendar periods
`index_by()`와 `summarise()`를 이용하면 관심있는 변수에 대해 특정 시간 주기(e.g. monthly)에 대해 함수(e.g. 합계: `sum()`, 평균: `mean()`)를 적용할 수 있다. `index_by`는 `as.Date()`, `tsibble::yearweek()`, `tsibble::yearmonth()`, `tsibble::yearquarter()`, 뿐만 아니라 {lubridate} 계열의 함수와 함께 사용된다. 예를 들어, `weather` 자료의 월별 평균 기온, 총 강수량은 다음과 같이 `yearmonth()`에 `index` 변수를 `.`으로 나타내어 계산할 수 있다.
```{r}
weather_tsbl %>% 
    group_by_key() %>% 
    index_by(year_month = ~yearmonth(.)) %>%
    summarise(
        avg_temp = mean(temp, na.rm = TRUE),
        total_precip = sum(precip, na.rm = TRUE)
    )
```

`index_by()`+`summarise()`는 irregular time interval을 갖는 tsibble에 대해서도 수행이 가능하다.

<br>

<a href='https://tsibbledata.tidyverts.org/'><img src='logo_tsibbledata.png' align="right" height="138.5" /></a>

## **3 tsibbledata**
***
{tsibbledata}는 tsibble 형태의 다양한 예제 자료를 제공해줍니다. 어떤 패키지에 대한 튜토리얼을 진행할 때, 적절한 자료들이 필요로 되는데, 이렇게 예제 자료를 직접적으로 제공해준다는 점에서 R 유저들에 대한 배려가 담겨있다는 생각이 드네요. 예를 들어, 다음의 `olympic_running`은 4년 주기로 수집된 올림픽 달리기 종목의 성별 최고기록에 관한 자료입니다(see `?olympic_running` for details).
```{r}
olympic_running
```

이 자료를 이용하여 달리기 종목별 최고 기록에 대한 시도표를 성별로 나누어서 그려보았습니다. 참고로, 1916, 1940, 1944년의 경우 세계대전으로 인해 결측 처리되었습니다.

```{r olympic, warning = FALSE, out.width = "80%", fig.align = "center"}
ggplot(olympic_running, aes(x = Year, y = Time, colour = Sex)) +
  geom_line() +
  geom_point(size = 1) +
  facet_wrap(~ Length, scales = "free_y", nrow = 2) + 
  theme_minimal() + 
  scale_color_brewer(palette = "Dark2") + 
  theme(legend.position = "bottom", legend.title = element_blank()) +
  ylab("Running time (seconds)")
```

<br>

<a href='https://feasts.tidyverts.org'><img src='logo_feasts.png' align="right" height="138.5" /></a>

## **4 feasts**
***
{feasts}는 Feature Extraction And Statistics for Time Series의 약자로, 시계열 자료분석에 쓰이는 여러가지 툴을 제공해줍니다. tsibble 객체와 함께 동작하며, 시계열의 분해, feature 추출(e.g. 추세, 계절성), 시각화 등을 수행할 때 쓰입니다. 아울러, {feasts}를 통한 시계열 자료분석은 다음 섹션에서 소개할 tidyverts ecosystem의 예측 모델링 부분을 담당하는 {fable} 패키지와 긴밀하게 결합하여 사용됩니다.

### 4.1 Graphics
시각화는 주로 시계열 자료의 패턴을 이해하기 위한 첫 단계에 많이 이루어집니다. {feasts}는 시계열의 패턴을 {ggplot2}를 사용해 자유롭게 커스텀할 수 있는 그래픽을 제공합니다. 첫 번째로는 `gg_season`을 이용한 계절성(seasonality) 시각화입니다. 시각화에 사용된 자료 `tsibbledata::aus_production`은 호주의 맥주, 담배 등의 품목에 관한 분기별 생산지표 추정치에 관한 자료입니다. 맥주의 분기별 생산지표에 관한 계절성 시각화를 수행해보았습니다:

```{r season, warning = FALSE, out.width = "80%", fig.align = "center"}
aus_production %>% 
  gg_season(Beer)
```

다음으로 `gg_subseries()`를 이용하면 시계열의 각 season별로 시각화가 가능합니다. 예를 들어, `aus_production`과 같은 분기별 자료의 경우 분기별 패턴에 대한 시각화를 쉽게 수행할 수 있습니다:

```{r subseries, warning = FALSE, out.width = "80%", fig.align = "center"}
aus_production %>% 
  gg_subseries(Beer)
```

`gg_lag()`를 이용하면 원자료와 시차(lag)의 산점도를 season별로 나누어 그릴 수 있습니다:
```{r lag, warning = FALSE, out.width = "80%", fig.align = "center"}
aus_production %>% 
  filter(year(Quarter) > 1991) %>% 
  gg_lag(Beer, geom = "point")
```

분기별 자료의 특성상, lag 4와 8 그림을 보면 각 season별로 원자료와의 관계가 $y=x$ 직선에 잘 놓여있는 것을 캐치할 수 있죠. 마지막으로 ACF 그림도 손쉽게 그릴 수 있습니다:
```{r acf, warning = FALSE, out.width = "80%", fig.align = "center"}
aus_production %>% 
  ACF(Beer) %>% 
  autoplot()
```

### 4.2 Decompositions
시계열 분해(decomposition)는 시계열 자료분석에서 흔히 수행되는 작업 중 하나이며, 이는 시계열에 대한 패턴을 이해하는데에 큰 도움을 줍니다. 그리고, 추후 예측 모델링을 정교하게 하는 것에도 상당한 도움을 준다. 즉, 시계열 분해는 본인이 분석하고자 하는 시계열의 패턴을 좀 더 정교하게 캐치하고 예측 성능을 향상시키기 위한 목적으로 꼭 필요로 되는 사전 작업이라고 할 수 있습니다. 본 튜토리얼에서는 {feasts}에서 제공하고 있는 2가지 시계열 분해 방법에 대해 소개하려고 합니다.

#### 4.2.1 Classical decompostion
classical decompostion은 1920년대에 고안된 방법입니다. 오래된 방법론인 만큼 요즘 쓰이는 시계열 분해 방법들의 초석이 되는 방법이라고 할 수 있으며, 다른 방법들에 비해 상대적으로 간단하다는 장점이 있습니다. classical decompostion은 가법 분해와 승법 분해가 있습니다. 두 방법은 계절성의 반영 방식에 따라 나뉩니다(e.g. 분기별 자료 $m = 4$, 월별 자료 $m = 12$, 일별 자료 $m = 7$). 보통 가법 classical decompostion의 경우 계절성이 추세에 따라 무관하게 일정한 크기를 유지할 때 사용하며, 반대로 계절성의 크기가 추세의 크기에 따라 변화하는 경우에는 승법 classical decompostion을 사용합니다. 승법 계절성  classical decompostion는 계절 성분이 연도에 따라 상수라고 가정한채로 진행되며, 승법 계절성에서 계절 성분을 형성하는 $m$은 계절 지수(seasonal indices)라 불리기도 합니다.

<br>

classical decompostion의 자세한 분해 과정은 [여기](https://otexts.com/fpp3/classical-decomposition.html)를 참고해주시기 바랍니다. 여기서는 바로 R을 이용한 튜토리얼을 진행하겠습니다. 앞서 사용했던 자료의 맥주 생산지표를 가법 classical decomposition을 통해 분해해보겠습니다.
```{r}
dcmp <- aus_production %>%
    model(classical_decomposition(Beer, type = "additive"))
components(dcmp)
```

먼저, 분해된 시계열의 요소들은 `componenets()`로 불러올 수 있습니다. 그리고, 이 `components()`에 대해 `autoplot()`을 수행해주면 다음과 같이 시각화를 수행할 수 있습니다:

```{r classical, warning = FALSE, out.width = "80%", fig.align = "center"}
dcmp %>%
    components() %>% 
    autoplot() +
    labs(title = "Classical additive decomposition of Quarterly production of beer in Australia")
```

#### 4.2.2 STL decomposition
STL은 "Seasonal and Trend decomposition using Loess"의 준말로 다재다능(versatile)하고 로버스트한 시계열 분해 방법에 해당한다. 여기서 loess란, [Local regression](https://be-favorite.tistory.com/58?category=923110)의 준말로 자료를 비선형으로 추정하는 방법 중 하나에 해당한다. STL은 앞서 소개한 classical decomposition, 그리고 {feasts}에서 제공하는 또 다른 시계열 분해 방법 [SEATS, X-11](https://otexts.com/fpp3/methods-used-by-official-statistics-agencies.html)과 비교하여 몇몇 이점을 갖는다. 자세한 사항은 [여기](https://otexts.com/fpp3/stl.html)를 참고해주세요. 본 글은 tidyverts ecosystem에 대한 소개 이므로, deep한 이론 정리는 추후에 fpp3 책을 공부하면서 하나하나 정리해나가겠습니다. 일단 바로 실습으로 넘어가겠습니다.`r emo::ji("blush")` 다음은 STL decomposition을 이용하여 시계열의 추세 요소는 `window = 7`을 통해 좀 더 flexible하게 추정하고, 계절 패턴의 경우는 `window = "periodic"`으로 하여 고정(fixed)되도록 하였습니다(see `?STL` for details). 여기서. `window`란, 창을 말하며 자료를 여러 창으로 잘게 쪼갤수록 더 flexible하고 복잡한 함수를 추정하게 됩니다. [splines](https://be-favorite.tistory.com/56?category=923110)에 지식이 있는 분들은 이해하기 쉬울거라고 생각합니다. 

```{r STL, warning = FALSE, out.width = "80%", fig.align = "center"}
aus_production %>%
  model(
    STL(Beer ~ trend(window = 7) + season(window = "periodic"),
        robust = TRUE)) %>%
  components() %>%
  autoplot()
```

### 4.3 Feature extraction and statistics
{feast}에서 소개할 마지막 기능은 시계열의 feature(e.g. ACF)와 통계량(e.g. 평균)을 뽑아내는 것입니다. {feast}에서는 `feature()` 함수를 통해 많은 종류의 features들에 대한 정보를 제공합니다만, 본 튜토리얼에서는 시계열의 평균, 분위수, ACF를 뽑아내는 방법에 대해서만 소개하겠습니다(see `?feature` for details). 그 외 다른 features들에 관심이 있으시다면, [여기](https://otexts.com/fpp3/some-simple-statistics.html)를 참고해주세요.

#### 4.3.1 Some simple statistics
먼저, 시계열의 평균과 분위수를 뽑는 방법에 대해 소개하겠습니다. 평균, 분위수 등 시계열의 기본적인 통계량은 `feature()`와 R의 기본 함수(e.g. `mean()`, `median()`)들을 이용해 간편하게 계산할 수 있습니다. 여기서 이용할 자료 `tourism()`은 지역, 주, 목적별로 나눠진 1998-2016년 분기별 호주 여행객수에 관한 자료로, 지역, 주, 여행 목적별 여행객 수의 전체 평균과 분위수를 계산해봤습니다:
```{r}
tourism %>%
    features(Trips, 
             list(mean = mean, quantile))
```

#### 4.3.2 ACF features
ACF에 관한 정보는 `feat_acf()`를 이용하면 됩니다. `feat_acf()`는 기본적으로 ACF와 관련한 6가지 또는 최대 7가지의 features를 제공해줍니다(see `?feat_acf()` for details):

* 원 계열의 1차 자기상관계수
* 원 계열의 1차-10차 자기상관계수의 제곱합
* 1차 차분 계열의 1차 자기상관계수
* 1차 차분 계열의 1차-10차 자기상관계수의 제곱합
* 2차 차분 계열의 1차 자기상관계수
* 2차 차분 계열의 1차-10차 자기상관계수의 제곱합
* (계절 시계열에 대해) 첫번째 계절 시차(seasonal lag)에서의 자기상관계수

```{r}
tourism %>% 
  features(Trips, feat_acf)
```

맨 마지막 열이 첫번째 계절 시차에서의 자기상관계수를 나타내는데, 본 자료의 경우 분기별 자료에 해당하므로 계절 주기는 4에 해당합니다. 즉, 본 자료에서 첫번째 계절 시차에서의 자기상관계수는 원 계열의 시차 4에서의 ACF 값을 나타낸다고 할 수 있습니다.
```{r}
tourism %>% 
  features(Trips, feat_acf) %>% 
  select(Region:Purpose, season_acf1)
```

원자료에 대한 ACF를 구해보면 다음과 같이 시차 4에서의 자기상관계수와 동일한 값을 가짐을 알 수 있죠:
```{r}
tourism %>% 
  ACF(Trips)
```

본 튜토리얼에서는 소개하지 않았지만, `feature()`를 이용한 시계열 feature extraction과 연계하여 다양한 시각화도 수행할 수 있습니다. 꼭 참고해보시기 바랍니다: https://otexts.com/fpp3/stlfeatures.html

<br>

<a href='https://fable.tidyverts.org'><img src='logo_fable.png' align="right" height="138.5" /></a>

## **5 fable**
***
{fable} 패키지는 tsibble 객체와 함께 tidy한 format으로 시계열 예측 모델링을 수행할 수 있게해줍니다. [{tidymodels}](https://github.com/be-favorite/Tutorial_tidymodels) 패키지에 대한 이해가 있으신 분들이라면 어렵지 않으실거라 생각합니다. {tidymodels}과 마찬가지로 {fable}은 여러 시계열에 대해 여러 시계열 모형에 대한 추정, 비교, 결합, 예측 등을 가능하게해줍니다.

본격적인 튜토리얼 시작에 앞서, `tourism()` 자료를 이용할 것이며, 4가지 여행 목적("business", "holiday", "visiting friends and relatives", "other reasons")으로 분해할 수 있는 호주 멜버른(Melbourne)의 일별 여행객 수를 예측하는 것에 관심이 있다고 가정합니다. 각 계열의 첫 번째 관측값은 다음과 같습니다:
```{r}
tourism_melb <- tourism %>% 
  filter(Region == "Melbourne")
tourism_melb %>% 
  group_by(Purpose) %>% 
  slice(1)
```

우리가 추정하고자 하는 변수는 `Trips`(일별 여행객 수, 단위: 천)입니다. 해당 계열들의 시도표를 보면, 추세와 약한 계절성이 명확하게 존재함을 알 수 있습니다.
```{r melbourne, warning = FALSE, out.width = "80%", fig.align = "center"}
tourism_melb %>% 
  autoplot(Trips)
```

<br>

## **7 Reference**{#anchor1}
***
* https://tidyverts.org/
* https://github.com/earowang/tsibbletalk